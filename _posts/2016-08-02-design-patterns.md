---
layout: post
title:  "Design Patterns with Head First"
date:   2016-08-02 20:32:00 +0900
categories: design patterns
---

헤드퍼스트를 통한 디자인 패턴 공부 시작

# 13. 패턴과 함께 하는 행복한 삶

## 디자인 패턴의 정의

> 패턴이란 특정 컨텍스트 내에서 주어진 문제에 대한 해결책이다.

컨텍스트(context)란 패턴이 적용되는 상황을 뜻하며 반복적으로 일어날 수 있는 상황이어야 한다.  
문제(problem)란 그 컨텍스트 내에서 이루고자 하는 목적을 뜻한다. 컨텍스트 내에서 생길 수 있는 제약조건도 문제에 포함된다.  
해결책(solution)은 누구든지 적용해서 일련의 제약조건 내에서 목적을 달성할 수 있는 일반적인 디자인을 뜻한다.  

> 어떤 컨텍스트 내에서 일련의 제약조건에 의해 영향을 받을 수 있는 문제에 봉착했다면,   
> 그 제약조건 내에서 목적을 달성하기 위한 해결책을 찾아낼 수 있는 디자인을 적용하면 된다.

## 패턴의 분류

1. 생성 패턴 (Creational Pattern)
2. 구조 패턴 (Structural Pattern)
3. 행동 패턴 (Behavioral Pattern)

> 패턴은 도구이지 목적이 되면 안된다.   
> 문제를 해결하는 데에 있어서 더 간단한 해결책이 존재한다면 그것이 정답이다.

# 9. 잘 관리된 컬렉션: 이터레이터와 컴포지트 패턴

## 이터레이터 패턴 (Iterator Pattern)

> 반복을 캡슐화한다.

> 컬렉션은 객체를 모아놓은 것에 불과하다.

> 이터레이터 패턴은 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에  
> 접근할 수 있게 해주는 방법을 제공한다.

### 단일 역할 원칙
> 한 클래스에서는 한가지 역할만 맡도록 해야 한다. 클래스를 바꾸는 이유는 한 가지 뿐이어야 한다.

> 응집도 (cohesion)란 한 클래스 또는 모듈이 특정 목적 또는 역할을 얼마나 일관되게 지원하는지를 나타내는 척도이다.

## 컴포지트 패턴 (Composite Pattern)

> 객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층구조로 만들 수 있다.  
> 클라이언트에서 개별 객체와 다른 객체들로 구성된 복합 객체 (composite)를 똑같은 방법으로 다룰 수 있다.

> 다른 구성요소를 포함하고 있는 구성요소는 복합 객체 (composite object)라고 부르고  
> 다른 구성요소를 포함하지 않는 구성요소는 잎 객체 (leaf object)라고 부른다.

> 똑같은 방법으로 다룬다는 의미는 복합 객체와 잎 객체 모두에 대해 똑같은 메소드를 호출한다는 것을 뜻한다.

# 7. 어댑터 패턴과 퍼사드 패턴

> 데코레이터 패턴은 인터페이스는 바꾸지 않고 책임(기능)만 추가하며  
> 어댑터 패턴은 한 인터페이스를 다른 인터페이스로 변환하며  
> 퍼사드 패턴은 인터페이스를 간단하게 바꾼다.

## 어댑터 패턴 (Adapter Pattern)

한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환한다.  
어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.

객체, 클래스 어댑터 패턴이 존재하며 객체 어댑터의 경우 객체 구성 (composition)을 사용하며  
클래스 어댑터 패턴의 경우 다중 상속 (multiple inheritance)을 사용한다.

### 클라이언트 (Client), 어댑터 (Adapter), 어댑티 (Adaptee)
클라이언트는 타겟 인터페이스에 맞게 구현되어 있으며 어댑터에게 요청 (request)을 보내며  
어댑터는 받은 요청을 어댑티에게 요청 (translated request)한다.

## 퍼사드 패턴 (Facade Pattern)

어떤 서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공한다.  
퍼사드에서 고수준 인터페이스를 정의하기 때문에 서브시스템을 더 쉽게 사용할 수 있다.

### 최소지식 원칙 (Principle of Least Knowledge)
> 정말 친한 친구하고만 얘기하라 (**= Law of Demeter**)

> 시스템을 디자인할 때 어떤 객체든 그 객체와 상호작용을 하는 클래스의 개수에 주의해야 하며,  
> 그런 객체들과 어떤 식으로 상호작용을 하는지에도 주의를 기울여야 한다.

다음 4가지 종류의 객체의 메소드의 호출만이 허용된다.

1. 객체 자체
2. 그 객체에 속하는 구성요소
3. 메소드에 매개변수로 전달된 객체
4. 그 메소드에서 생성하거나 인스턴스를 만든 객체

#### 최소지식 원칙의 장점과 단점
객체들 사이의 의존성을 줄일 수 있고, 소프트웨어 관리가 더 용이해질 수도 있다.
하지만 이 원칙을 적용하다보면 다른 구성요소에 대한 메소드 호출을 처리하기 위해 "래퍼" 클래스를
더 만들어야 할 수도 있다. 그러다 보면 시스템이 더 복잡해지고, 개발 시간도 늘어나고, 성능도 떨어질 수 있다.

> 각 디자인마다 장단점 (추상화 vs 속도, 공간 vs 시간 등)이 있기 때문에  
> 원칙이 어떤 가이드 라인을 제시해 주긴 하지만, 직접 적용하기 전에 모든 요인들을 살펴봐야 합니다.

# 6. 호출 캡슐화: 커맨드 패턴
> 요구 사항을 객체로 캡슐화 할 수 있으며, 매개변수를 써서 여러 가지 다른 요구 사항을 집어넣을 수도 있다.  
> 또한 요청 내역을 큐에 저장하거나 로그로 기록할 수도 있으며, 작업취소 기능도 지원 가능하다.

클라이언트, 커맨드, 인보커 (invoker), 리시버 (receiver)

> 커맨드 객체란 일련의 행동을 특정 리시버하고 연결시킴으로써 요구 사항을 캡슐화한 것이다.  
> 행동과 리시버를 한 객체에 집어넣고, execute()라는 메소드 하나만 외부에 공개하는 방법을 쓴다.  
> 외부에서 볼 때는 어떤 객체가 리시버 역할을 하는지, 그 리시버에서 실제로 어떤 일을 하는 지 알 수 없다.

# 8. 알고리즘 캡슐화: 템플릿 메소드 패턴
> 알고리즘의 골격을 정의한다.  
> 알고리즘의 여러 단계 중 일부는 서브클래스에서 구현할 수 있으며  
> 템플릿 메소드를 이용하면 알고리즘의 구조는 그대로 유지하면서 서브클래스에서 특정 단계를 재정의할 수 있다.

### 용어정리

#### 후크
추상 클래스에서 선언되는 메소드이지만 기본적인 내용만 구현되어 있거나 아무 코드도 들어있지 않은 메소드.  
서브클래스의 필요에 따라 오버라이드할 수도 있고 그냥 사용할 수도 있다.

### 템플릿 메소드 패턴 vs 스트래티지 패턴
> 템플릿 메소드 패턴은 알고리즘의 개요, 구조를 정의하며 실제 작업 중 일부는 서브클래스에서 처리할 수 있다.  
> 스트래티지 패턴은 알고리즘군을 정의하고 그 알고리즘들을 서로 바꿔가면서 쓸 수 있게 해준다.  
> 객체 구성을 사용하기에 더 유연하다.

> 전자는 상속, 후자는 객체 구성을 이용한다.

# 10. 객체의 상태: 스테이트 패턴
> 객체 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있다.

## State Pattern vs Strategy Pattern
State Pattern에서는 상태 객체에 일련의 행동이 캡슐화된다. 상황에 따라 Context 객체에서 여러 상태 객체 중 한 객체에게 모든 행동을 맡기게 된다.
클라이언트는 상태 객체에 대해서 거의 아무 것도 몰라도 된다. 하지만 Strategy Pattern에서는 일반적으로 클라이언트에서 컨텍스트 객체한테 어떤
전략 객체를 사용할 지를 지정해준다. 즉, 주로 실행시에 전략 객체를 변경할 수 있는 유연성을 제공하기 위한 용도로 쓰인다.

# 11. 객체 접근 제어: 프록시 패턴
> 어떤 객체에 대한 접근을 제어하기 위한 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴

## 종류
1. 원격 프록시(remote proxy) : 원격 객체에 대한 접근 제어 가능
2. 가상 프록시(virtual proxy) : 생성하기 힘든 자원에 대한 접근 제어 가능
3. 보호 프록시(protection proxy) : 접근 권한이 필요한 자원에 대한 접근 제어 가능
4. 캐싱 프록시(caching proxy) : 기존에 생성했던 객체들을 저장 후 요청이 들어왔을 때 상황에 따라 캐시에 저장되어 있는 객체를 리턴 가능
5. 방화벽 프록시 : 일련의 네트워크 자원에 대한 접근을 제어함으로써 주 객체를 "나쁜" 클라이언트들로부터 보호 가능
6. 스마트 레퍼런스 프록시(smart reference proxy) : 주 객체가 참조될 때마다 추가 행동을 제공 가능
7. 동기화 프록시(synchronization proxy) : 여러 스레드에서 주 객체에 접근하는 경우에 안전하게 작업을 처리 가능
8. 복잡도 숨김 프록시(complexity hiding proxy, =facade proxy) : 복잡한 클래스들의 집합에 대한 접근을 제어하고, 그 복잡도를 숨김
9. 지연 복사 프록시(copy-on-write proxy) : 클라이언트에서 필요로 할 때까지 객체가 복사되는 것을 지연시킴으로써 객체의 복사를 제어

> 프록시 변종의 공통점은 클라이언트에서 실제 객체를 호출하면, 그 호출을 중간에 가로챈다는 것이다.

## Decorater Pattern vs Proxy Pattern
데코레이터 패턴과 거의 똑같아 보일 수 있다. 하지만 그 용도에 따라 구분할 수 있다.  
데코레이터는 클래스에 새로운 행동을 추가하기 위한 용도로 쓰이지만, 프록시는 어떤 클래스에 대한  
접근을 제어하기 위한 용도로 사용된다.

## Adapter Pattern vs Proxy Pattern
어댑터에서는 다른 객체의 인터페이스를 바꿔주지만, 프록시에서는 똑같은 인터페이스를 사용한다.